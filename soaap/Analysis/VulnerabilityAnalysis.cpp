#include "Analysis/VulnerabilityAnalysis.h"
#include "Common/CmdLineOpts.h"
#include "Common/Debug.h"
#include "Common/XO.h"
#include "Util/CallGraphUtils.h"
#include "Util/PrettyPrinters.h"
#include "soaap.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DebugInfo.h"
#include "llvm/IR/IntrinsicInst.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/raw_ostream.h"

#include <cxxabi.h>

using namespace soaap;

void VulnerabilityAnalysis::doAnalysis(Module& M, SandboxVector& sandboxes) {
  findPastVulnerabilityAnnotations(M);
  findVulnerableVendorFuncs(M);
  findVulnerableLibFuncs(M);
  checkLeakedRights(M, sandboxes);
}

void VulnerabilityAnalysis::findPastVulnerabilityAnnotations(Module& M) {
  // Find all annotated code blocks. Note, we do this by inserting calls to 
  // the function __soaap_past_vulnerability_at_point. This function is declared
  // static to avoid linking problems when linking multiple modules. However,
  // as a result of this, a number may be appended to its name to make it unique.
  // We therefore have to search through all the functions in M and find those
  // that start with __soaap_past_vulnerability_at_point
  string pastVulnFuncBaseName = "__soaap_past_vulnerability_at_point";
  for (Function& F : M.getFunctionList()) {
    if (F.getName().find(pastVulnFuncBaseName) != StringRef::npos) {
      dbgs() << "   Found function " << F.getName() << "\n";
      for (User* U : F.users()) {
        if (CallInst* call = dyn_cast<CallInst>(U)) {
          //call->dump();
          Function* enclosingFunc = call->getParent()->getParent();
          if (shouldOutputWarningFor(enclosingFunc)) {
            pastVulnAnnotatedPoints.push_back(call);
            if (GlobalVariable* CVEGlobal = dyn_cast<GlobalVariable>(call->getArgOperand(0)->stripPointerCasts())) {
              ConstantDataArray* CVEGlobalArr = dyn_cast<ConstantDataArray>(CVEGlobal->getInitializer());
              StringRef CVE = CVEGlobalArr->getAsCString();
              funcToCVEs[enclosingFunc].insert(CVE);
              vulnerableFuncs.insert(enclosingFunc);
            }
          }
        }
      }
    }
  }

  // Find all annotated functions
  GlobalVariable* lga = M.getNamedGlobal("llvm.global.annotations");
  if (lga != NULL) {
    ConstantArray* lgaArray = dyn_cast<ConstantArray>(lga->getInitializer()->stripPointerCasts());
    for (User::op_iterator i=lgaArray->op_begin(), e = lgaArray->op_end(); e!=i; i++) {
      ConstantStruct* lgaArrayElement = dyn_cast<ConstantStruct>(i->get());

      // get the annotation value first
      GlobalVariable* annotationStrVar = dyn_cast<GlobalVariable>(lgaArrayElement->getOperand(1)->stripPointerCasts());
      ConstantDataArray* annotationStrArray = dyn_cast<ConstantDataArray>(annotationStrVar->getInitializer());
      StringRef annotationStrArrayCString = annotationStrArray->getAsCString();

      GlobalValue* annotatedVal = dyn_cast<GlobalValue>(lgaArrayElement->getOperand(0)->stripPointerCasts());
      if (isa<Function>(annotatedVal)) {
        Function* annotatedFunc = dyn_cast<Function>(annotatedVal);
        if (annotationStrArrayCString.startswith(PAST_VULNERABILITY)) {
          if (shouldOutputWarningFor(annotatedFunc)) {
            int status = -4;
            char* demangled = abi::__cxa_demangle(annotatedFunc->getName().str().c_str(), 0, 0, &status);
            dbgs() << "   Found annotated function " << (status ? annotatedFunc->getName() : demangled) << "\n";
            pastVulnAnnotatedFuncs.push_back(annotatedFunc);
            StringRef CVE = annotationStrArrayCString.substr(strlen(PAST_VULNERABILITY)+1);
            funcToCVEs[annotatedFunc].insert(CVE);
            vulnerableFuncs.insert(annotatedFunc);
          }
        }
      }
    }
  }
}

void VulnerabilityAnalysis::findVulnerableVendorFuncs(Module& M) {
  // provenance is recorded in compilation units with a variable called
  // __soaap_provenance_var. This variable has hidden visibility so that
  // the linker doesn't complain when linking multiple compilation units
  // together.
  string provenanceVarBaseName = "__soaap_provenance";
  SmallVector<DICompileUnit*,16> CUs;
  if (NamedMDNode* CUMDNodes = M.getNamedMetadata("llvm.dbg.cu")) {
    for(unsigned i = 0, e = CUMDNodes->getNumOperands(); i != e; i++) {
      DICompileUnit* CUMDNode = cast<DICompileUnit>(CUMDNodes->getOperand(i));
      CUs.push_back(CUMDNode);
    }
  }

  // each __soaap_provenance global var is defined in exactly one CU,
  // so remove a CU from CUs once it has be attributed to a var
  for (GlobalVariable& G : M.getGlobalList()) {
    if (G.getName().startswith(provenanceVarBaseName)) {
      dbgs() << "Found global variable " << G.getName() << "\n";
      GlobalVariable* provenanceStrVar = dyn_cast<GlobalVariable>(G.getInitializer()->stripPointerCasts());
      ConstantDataArray* provenanceArr = dyn_cast<ConstantDataArray>(provenanceStrVar->getInitializer());
      StringRef provenanceStr = provenanceArr->getAsCString(); // getAsString adds '\0' as an additional character
      dbgs() << "  Provenance: " << provenanceStr << "\n";

      if (find(CmdLineOpts::VulnerableVendors.begin(), CmdLineOpts::VulnerableVendors.end(), provenanceStr) != CmdLineOpts::VulnerableVendors.end()) {
        outs() << "   " << provenanceStr << " is a vulnerable vendor\n";
        // Find out what the containing compilation unit and all its functions
        for(unsigned i = 0, ei = CUs.size(); i != ei; i++) {
          DICompileUnit* CU = CUs[i];
          DIGlobalVariableArray CUGlobals = CU->getGlobalVariables();
          for (unsigned j = 0, ej = CUGlobals.size(); j != ej; j++) {
            DIGlobalVariable* CUGlobal = CUGlobals[j];
            if (CUGlobal->getVariable() == &G) {
              outs() << "    Found containing compile unit for " << G.getName() << ", list functions:\n";
              DISubprogramArray CUSubs = CU->getSubprograms();
              for (unsigned k = 0, ek = CUSubs.size(); k != ek; k++) {
                DISubprogram* CUSub = CUSubs[k];
                if (Function* CUFunc = CUSub->getFunction()) {
                  if (shouldOutputWarningFor(CUFunc)) {
                    outs() << "      " << CUFunc->getName() << "()\n";
                    // record that CUFunc is vulnerable
                    if (find(vulnerableVendorFuncs.begin(), vulnerableVendorFuncs.end(), CUFunc) == vulnerableVendorFuncs.end()) {
                      vulnerableVendorFuncs.push_back(CUFunc);
                      vulnerableFuncs.insert(CUFunc);
                    }
                  }
                }
              }
              CUs.erase(CUs.begin()+i); // remove CU from CUs
              goto outerloop;
            }
          }
        }
        outerloop:
        ;
      }
    }
  }
}

void VulnerabilityAnalysis::findVulnerableLibFuncs(Module& M) {
  for (Module::iterator F = M.begin(), E = M.end(); F != E; ++F) {
    string library = DebugUtils::getEnclosingLibrary(&*F);
    if (!library.empty()) {
      if (find(CmdLineOpts::VulnerableLibs.begin(), CmdLineOpts::VulnerableLibs.end(), library) != CmdLineOpts::VulnerableLibs.end()) {
        SDEBUG("soaap.analysis.vulnerability", 3, dbgs() << "Vulnerable library func: " << F->getName() << " (library " << library << ")\n");
        vulnerableFuncs.insert(F);
      }
    }
  }
}

// TODO: cache this info
pair<string,int> VulnerabilityAnalysis::findFuncDeclaration(Module& M, Function* F) {
  if (funcToSourceLoc.empty()) {
    if (NamedMDNode *NMD = M.getNamedMetadata("llvm.dbg.cu")) {
      for (int i=0; i<NMD->getNumOperands(); i++) {
        DICompileUnit* CU = cast<DICompileUnit>(NMD->getOperand(i));
        DISubprogramArray functions = CU->getSubprograms();
        for (int j=0; j<functions.size(); j++) {
          DISubprogram* FN = functions[j];
          if (Function* F = FN->getFunction()) {
            funcToSourceLoc[F] = make_pair<string,int>(FN->getFilename(), FN->getLine());
          }
        }
      }
    }
  }
  return funcToSourceLoc[F];
}

void VulnerabilityAnalysis::checkLeakedRights(Module& M, SandboxVector& sandboxes) {

  XO::List vulnerabilityWarningList("vulnerability_warning");
  for (Function* F : vulnerableFuncs) {
    for (Sandbox* S : sandboxes) {
      if (S->containsFunction(F)) {
        XO::Instance vulnerabilityWarningInstance(vulnerabilityWarningList);
        XO::emit("{e:function/%s}", F->getName().str().c_str());
        XO::emit("{e:sandbox/%s}", S->getName().c_str());

        pair<string,int> loc = findFuncDeclaration(M, F);
        XO::Container location("location");
        XO::emit("{e:file/%s}{e:line/%d}",
                 loc.first.c_str(), loc.second);
        location.close();

        XO::emit("\n");
        map<Function*,StringSet>::iterator it = funcToCVEs.find(F);
        if (it == funcToCVEs.end()) {
          // vulnerable vendor func/library
          XO::emit("{e:type/%s}", "vulnerable_vendor");
          XO::emit(" *** Sandboxed function \"{d:function/%s}\" is from "
                   "a vulnerable vendor or library.\n",
                   F->getName().str().c_str());
          if (sandboxPlatform->doesProvideProtection()) {
            XO::emit("{e:restricted_rights/true}");
            XO::emit(" *** A vulnerability here would not grant ambient "
                     "authority to the attacker but would leak the "
                     "following restricted rights:\n");
          }
          else {
            XO::emit("{e:restricted_rights/false}");
            XO::emit(" *** A vulnerability here would leak ambient "
                     "authority to the attacker including full\n"
                     " *** network and file system access.\n"); 
            continue;
          }
        }
        else {
          // func with past vulnerabilities
          XO::emit("{e:type/%s}", "cve");
          StringSet CVEs = it->second;
          XO::emit(" *** Sandboxed function \"{d:function/%s}\" has "
                   "past-vulnerability annotations for \"{d:cves/%s}\".\n",
                   F->getName().str().c_str(),
                   stringifyStringSet(CVEs).c_str());
          XO::List cveList("cve");
          for (string cve : CVEs) {
            XO::Instance cveInstance(cveList);
            XO::emit("{e:id/%s}", cve.c_str());
          }
          cveList.close();
          if (sandboxPlatform->doesProvideProtection()) {
            XO::emit("{e:restricted_rights/%s}", "true");
            XO::emit(" *** Another vulnerability here would not grant ambient "
                     "authority to the attacker but would leak the "
                     "following restricted rights:\n");
          }
          else {
            XO::emit("{e:restricted_rights/%s}", "false");
            XO::emit(" *** Another vulnerability here would leak ambient "
                     "authority to the attacker including full\n"
                     " *** network and file system access.\n"); 
            continue;
          }
        }

        XO::Container rightsLeakedContainer("rights_leaked");
        // F may run in a sandbox
        // find out what was passed into the sandbox (shared global variables, file descriptors)
        SDEBUG("soaap.analysis.vulnerability", 3, dbgs() << "Checking leaking of global variables\n");
        GlobalVariableIntMap varToPerms = S->getGlobalVarPerms();
        if (!varToPerms.empty()) {
          XO::List globalList("global");
          XO::emit(" Global variables:\n");
          for (pair<GlobalVariable*,int> varPermPair : varToPerms) {
            XO::Instance globalInstance(globalList);
            GlobalVariable* G = varPermPair.first;
            int varPerms = varPermPair.second;
            StringRef varPermsStr = "";
            if (varPerms == (VAR_READ_MASK | VAR_WRITE_MASK)) {
              varPermsStr = "Read and write";
            }
            else if (varPerms & VAR_READ_MASK) {
              varPermsStr = "Read";
            }
            else if (varPerms) {
              varPermsStr = "Write";
            }
            if (varPermsStr != "") {
              XO::emit(" +++ {d:perms/%s} access to \"{:global_var/%s}\"\n",
                       varPermsStr.str().c_str(),
                       G->getName().str().c_str());
              XO::List permList("perm");
              if (varPerms & VAR_READ_MASK) {
                XO::Instance permInstance(permList);
                XO::emit("{e:type/%s}", "read");
              }
              if (varPerms & VAR_WRITE_MASK) {
                XO::Instance permInstance(permList);
                XO::emit("{e:type/%s}", "write");
              }
            }
          }
        }
        
        SDEBUG("soaap.analysis.vulnerability", 3, dbgs() << "Checking leaking of capabilities\n");
        ValueFunctionSetMap caps = S->getCapabilities();
        if (!caps.empty()) {
          XO::List capRightList("cap_right");
          XO::emit(" File descriptors:\n");
          for (pair<const Value*,FunctionSet> cap : caps) {
            const Argument* capArg = dyn_cast<const Argument>(cap.first);
            FunctionSet capPerms = cap.second;
            if (!capPerms.empty()) {
              XO::Instance capRightInstance(capRightList);
              XO::emit(" +++ Call {d:syscalls/%s} on file descriptor "
                       "\"{:fd/%s}\" passed into sandbox entrypoint "
                       "\"{:entry_point/%s}\"\n",
                       CallGraphUtils::stringifyFunctionSet(capPerms).c_str(),
                       capArg->getName().str().c_str(),
                       capArg->getParent()->getName().str().c_str());
              XO::List syscallList("syscall");
              for(Function* capPerm : capPerms) {
                XO::Instance syscallInstance(syscallList);
                XO::emit("{e:name/%s}", capPerm->getName().str().c_str());
              }
            }
          }
        }

        SDEBUG("soaap.analysis.vulnerability", 3, dbgs() << "Checking callgates\n");
        FunctionVector callgates = S->getCallgates();
        if (!callgates.empty()) {
          XO::List callgateList("callgate");
          XO::emit(" Call gates:\n");
          for (Function* F : callgates) {
            XO::Instance callgateInstance(callgateList);
            XO::emit(" +++ {:name/%s}\n",
                     F->getName().str().c_str());
          }
        }

        SDEBUG("soaap.analysis.vulnerability", 3, outs() << "Checking sandbox-private data\n");
        ValueSet privateData = S->getPrivateData();
        if (!privateData.empty()) {
          XO::List privateList("private");
          XO::emit(" Private data:\n");
          for (Value* V : privateData) {
            XO::Instance privateInstance(privateList);
            if (IntrinsicInst* annotateCall = dyn_cast<IntrinsicInst>(V)) {
              if (annotateCall->getIntrinsicID() == Intrinsic::var_annotation) {
                // llvm.var.annotation
                Value* annotatedVar = dyn_cast<Value>(annotateCall->getOperand(0)->stripPointerCasts());
                XO::emit("{e:type/%s}", "local_var");
                XO::emit(" +++ Local variable \"{:name/%s}\"\n",
                         annotatedVar->getName().str().c_str());
              }
              else if (annotateCall->getIntrinsicID() == Intrinsic::ptr_annotation) {
                XO::emit("{e:type/%s}", "struct_member");
                Value* annotatedVar = dyn_cast<Value>(annotateCall->getOperand(0)->stripPointerCasts());
                XO::emit(" +++ Struct member \"{:name/%s}\"\n",
                         annotatedVar->getName().str().c_str());
              }
            }
            else if (GlobalVariable* G = dyn_cast<GlobalVariable>(V)) {
              XO::emit("{e:type/%s}", "global_var");
              XO::emit(" +++ Global variable \"{:name/%s}\"\n",
                       G->getName().str().c_str());
            }
          }
        }

        rightsLeakedContainer.close();

        if (CmdLineOpts::isSelected(SoaapAnalysis::Vuln, CmdLineOpts::OutputTraces)) {
          CallGraphUtils::emitCallTrace(F, S, M);
        }

        SDEBUG("soaap.analysis.vulnerability", 3, outs() << "TODO: Check classified data\n");
      }
    }
    if (find(privilegedFuncs.begin(), privilegedFuncs.end(), F) != privilegedFuncs.end()) {
      // F may run with ambient authority
      XO::Instance vulnerabilityWarningInstance(vulnerabilityWarningList);
      XO::emit("{e:function/%s}", F->getName().str().c_str());
      XO::emit("{en:sandbox/null}");
      
      pair<string,int> loc = findFuncDeclaration(M, F);
      XO::Container locationContainer("location");
      XO::emit("{e:file/%s}{e:line/%d}",
               loc.first.c_str(), loc.second);
      locationContainer.close();
      XO::emit("{e:restricted_rights/false}");
      
      XO::emit("\n");
      map<Function*,StringSet>::iterator it = funcToCVEs.find(F);
      if (it == funcToCVEs.end()) {
        XO::emit("{e:type/%s}", "vulnerable_vendor");
        XO::emit(" *** Function \"{d:function/%s}\" is from a vulnerable "
                 "vendor.\n"
                 " *** A vulnerability here would leak ambient authority "
                 "to the attacker including full\n"
                 " *** network and file system access.\n",
                 F->getName().str().c_str()); 
      }
      else {
        XO::emit("{e:type/%s}", "cve");
        StringSet CVEs = it->second;
        XO::emit(" *** Function \"{d:function/%s}\" has "
                 "past-vulnerability annotations for \"{d:cves/%s}\".\n"
                 " *** Another vulnerability here would leak ambient "
                 "authority to the attacker including full\n"
                 " *** network and file system access.\n",
                 F->getName().str().c_str(),
                 stringifyStringSet(CVEs).c_str());
        XO::List cveList("cve");
        for (string cve : CVEs) {
          XO::Instance cveInstance(cveList);
          XO::emit("{e:id/%s}", cve.c_str());
        }
      }
      if (CmdLineOpts::isSelected(SoaapAnalysis::Vuln, CmdLineOpts::OutputTraces)) {
        CallGraphUtils::emitCallTrace(F, nullptr, M);
      }
    }
  }
}

string VulnerabilityAnalysis::stringifyStringSet(StringSet& strings) {
  string str = "[";
  bool first = true;
  for (string s : strings) {
    if (!first) 
      str += ",";
    str += s;
    first = false;
  }
  str += "]";
  return str;
}
