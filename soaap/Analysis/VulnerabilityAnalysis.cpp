/*
 * Copyright (c) 2013-2015 Khilan Gudka
 * All rights reserved.
 *
 * This software was developed by SRI International and the University of
 * Cambridge Computer Laboratory under DARPA/AFRL contract FA8750-10-C-0237
 * ("CTSRD"), as part of the DARPA CRASH research programme.
 *
 * This software was developed at the University of Cambridge Computer
 * Laboratory with support from a grant from Google, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "Analysis/VulnerabilityAnalysis.h"
#include "Common/CmdLineOpts.h"
#include "Common/Debug.h"
#include "Common/XO.h"
#include "Util/CallGraphUtils.h"
#include "Util/PrettyPrinters.h"
#include "soaap.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DebugInfo.h"
#include "llvm/IR/IntrinsicInst.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/raw_ostream.h"

#include <cxxabi.h>

using namespace soaap;

void VulnerabilityAnalysis::doAnalysis(Module& M, SandboxVector& sandboxes) {
  findPastVulnerabilityAnnotations(M);
  findVulnerableVendorFuncs(M);
  findVulnerableLibFuncs(M);
  checkLeakedRights(M, sandboxes);
}

void VulnerabilityAnalysis::findPastVulnerabilityAnnotations(Module& M) {
  // Find all annotated code blocks. Note, we do this by inserting calls to 
  // the function __soaap_past_vulnerability_at_point. This function is declared
  // static to avoid linking problems when linking multiple modules. However,
  // as a result of this, a number may be appended to its name to make it unique.
  // We therefore have to search through all the functions in M and find those
  // that start with __soaap_past_vulnerability_at_point
  string pastVulnFuncBaseName = "__soaap_past_vulnerability_at_point";
  for (Function& F : M.getFunctionList()) {
    if (F.getName().find(pastVulnFuncBaseName) != StringRef::npos) {
      dbgs() << "   Found function " << F.getName() << "\n";
      for (User* U : F.users()) {
        if (CallInst* call = dyn_cast<CallInst>(U)) {
          //call->dump();
          Function* enclosingFunc = call->getParent()->getParent();
          if (shouldOutputWarningFor(enclosingFunc)) {
            pastVulnAnnotatedPoints.push_back(call);
            if (GlobalVariable* CVEGlobal = dyn_cast<GlobalVariable>(call->getArgOperand(0)->stripPointerCasts())) {
              ConstantDataArray* CVEGlobalArr = dyn_cast<ConstantDataArray>(CVEGlobal->getInitializer());
              StringRef CVE = CVEGlobalArr->getAsCString();
              funcToCVEs[enclosingFunc].insert(CVE);
              vulnerableFuncs.insert(enclosingFunc);
            }
          }
        }
      }
    }
  }

  // Find all annotated functions
  GlobalVariable* lga = M.getNamedGlobal("llvm.global.annotations");
  if (lga != NULL) {
    ConstantArray* lgaArray = dyn_cast<ConstantArray>(lga->getInitializer()->stripPointerCasts());
    for (User::op_iterator i=lgaArray->op_begin(), e = lgaArray->op_end(); e!=i; i++) {
      ConstantStruct* lgaArrayElement = dyn_cast<ConstantStruct>(i->get());

      // get the annotation value first
      GlobalVariable* annotationStrVar = dyn_cast<GlobalVariable>(lgaArrayElement->getOperand(1)->stripPointerCasts());
      ConstantDataArray* annotationStrArray = dyn_cast<ConstantDataArray>(annotationStrVar->getInitializer());
      StringRef annotationStrArrayCString = annotationStrArray->getAsCString();

      GlobalValue* annotatedVal = dyn_cast<GlobalValue>(lgaArrayElement->getOperand(0)->stripPointerCasts());
      if (isa<Function>(annotatedVal)) {
        Function* annotatedFunc = dyn_cast<Function>(annotatedVal);
        if (annotationStrArrayCString.startswith(PAST_VULNERABILITY)) {
          if (shouldOutputWarningFor(annotatedFunc)) {
            int status = -4;
            char* demangled = abi::__cxa_demangle(annotatedFunc->getName().str().c_str(), 0, 0, &status);
            dbgs() << "   Found annotated function " << (status ? annotatedFunc->getName() : demangled) << "\n";
            pastVulnAnnotatedFuncs.push_back(annotatedFunc);
            StringRef CVE = annotationStrArrayCString.substr(strlen(PAST_VULNERABILITY)+1);
            funcToCVEs[annotatedFunc].insert(CVE);
            vulnerableFuncs.insert(annotatedFunc);
          }
        }
      }
    }
  }
}

void VulnerabilityAnalysis::findVulnerableVendorFuncs(Module& M) {
  // provenance is recorded in compilation units with a variable called
  // __soaap_provenance_var. This variable has hidden visibility so that
  // the linker doesn't complain when linking multiple compilation units
  // together.
  string provenanceVarBaseName = "__soaap_provenance";
  map<DICompileUnit*,FunctionSet> CUFuncs;

  for (Function& F : M.functions()) {
    if (DISubprogram* Sub = F.getSubprogram())
      CUFuncs[Sub->getUnit()].insert(&F);
  }
  /*SmallVector<DICompileUnit*,16> CUs;
  if (NamedMDNode* CUMDNodes = M.getNamedMetadata("llvm.dbg.cu")) {
    for(unsigned i = 0, e = CUMDNodes->getNumOperands(); i != e; i++) {
      DICompileUnit* CUMDNode = cast<DICompileUnit>(CUMDNodes->getOperand(i));
      CUs.push_back(CUMDNode);
    }
  }*/

  // each __soaap_provenance global var is defined in exactly one CU
  for (GlobalVariable& G : M.globals()) {
    if (G.getName().startswith(provenanceVarBaseName)) {
      dbgs() << "Found global variable " << G.getName() << "\n";
      GlobalVariable* provenanceStrVar = dyn_cast<GlobalVariable>(G.getInitializer()->stripPointerCasts());
      ConstantDataArray* provenanceArr = dyn_cast<ConstantDataArray>(provenanceStrVar->getInitializer());
      StringRef provenanceStr = provenanceArr->getAsCString(); // getAsString adds '\0' as an additional character
      dbgs() << "  Provenance: " << provenanceStr << "\n";

      if (find(CmdLineOpts::VulnerableVendors.begin(), CmdLineOpts::VulnerableVendors.end(), provenanceStr) != CmdLineOpts::VulnerableVendors.end()) {
        outs() << "   " << provenanceStr << " is a vulnerable vendor\n";
        // Find out what the containing compilation unit is and add all its functions
        SmallVector<DIGlobalVariableExpression*, 8> GVEs;
        G.getDebugInfo(GVEs);
        DIGlobalVariableExpression* GVE = GVEs.front();
        if (DICompileUnit* CU = dyn_cast<DICompileUnit>(GVE->getVariable()->getScope())) {
          outs() << "    Found containing compile unit for " << G.getName() << ", list functions:\n";
          for (Function* CUFunc : CUFuncs[CU]) {
            if (shouldOutputWarningFor(CUFunc)) {
              outs() << "      " << CUFunc->getName() << "()\n";
              // record that CUFunc is vulnerable
              if (find(vulnerableVendorFuncs.begin(), vulnerableVendorFuncs.end(), CUFunc) == vulnerableVendorFuncs.end()) {
                vulnerableVendorFuncs.push_back(CUFunc);
                vulnerableFuncs.insert(CUFunc);
              }
            }
          }
        }
        /*
        for(unsigned i = 0, ei = CUs.size(); i != ei; i++) {
          DICompileUnit* CU = CUs[i];
          DIGlobalVariableArray CUGlobals = CU->getGlobalVariables();
          for (unsigned j = 0, ej = CUGlobals.size(); j != ej; j++) {
            DIGlobalVariable* CUGlobal = CUGlobals[j];
            if (CUGlobal->getVariable() == &G) {
              outs() << "    Found containing compile unit for " << G.getName() << ", list functions:\n";
              DISubprogramArray CUSubs = CU->getSubprograms();
              for (unsigned k = 0, ek = CUSubs.size(); k != ek; k++) {
                DISubprogram* CUSub = CUSubs[k];
                if (Function* CUFunc = CUSub->getFunction()) {
                  if (shouldOutputWarningFor(CUFunc)) {
                    outs() << "      " << CUFunc->getName() << "()\n";
                    // record that CUFunc is vulnerable
                    if (find(vulnerableVendorFuncs.begin(), vulnerableVendorFuncs.end(), CUFunc) == vulnerableVendorFuncs.end()) {
                      vulnerableVendorFuncs.push_back(CUFunc);
                      vulnerableFuncs.insert(CUFunc);
                    }
                  }
                }
              }
              CUs.erase(CUs.begin()+i); // remove CU from CUs
              goto outerloop;
            }
          }
        }
        outerloop:
        ;*/
      }
    }
  }
}

void VulnerabilityAnalysis::findVulnerableLibFuncs(Module& M) {
  for (Function& F : M.functions()) {
    string library = DebugUtils::getEnclosingLibrary(&F);
    if (!library.empty()) {
      if (find(CmdLineOpts::VulnerableLibs.begin(), CmdLineOpts::VulnerableLibs.end(), library) != CmdLineOpts::VulnerableLibs.end()) {
        SDEBUG("soaap.analysis.vulnerability", 3, dbgs() << "Vulnerable library func: " << F.getName() << " (library " << library << ")\n");
        vulnerableFuncs.insert(&F);
      }
    }
  }
}

// TODO: cache this info
pair<string,int> VulnerabilityAnalysis::findFuncDeclaration(Module& M, Function* F) {
  if (funcToSourceLoc.empty()) {
    for (Function& F2 : M.functions()) {
      if (DISubprogram* Sub = F2.getSubprogram()) {
        funcToSourceLoc[&F2] = make_pair<string,int>(Sub->getFilename(), Sub->getLine());
      }
    }
  }
  /*
  for (int i=0; i<NMD->getNumOperands(); i++) {
    DICompileUnit* CU = cast<DICompileUnit>(NMD->getOperand(i));
    DISubprogramArray functions = CU->getSubprograms();
    for (int j=0; j<functions.size(); j++) {
      DISubprogram* FN = functions[j];
      if (Function* F = FN->getFunction()) {
        funcToSourceLoc[F] = make_pair<string,int>(FN->getFilename(), FN->getLine());
      }
    }
  }
  */
  return funcToSourceLoc[F];
}

void VulnerabilityAnalysis::checkLeakedRights(Module& M, SandboxVector& sandboxes) {

  XO::List vulnerabilityWarningList("vulnerability_warning");
  for (Function* F : vulnerableFuncs) {
    for (Sandbox* S : sandboxes) {
      if (S->containsFunction(F)) {
        XO::Instance vulnerabilityWarningInstance(vulnerabilityWarningList);
        XO::emit("{e:function/%s}", F->getName().str().c_str());
        XO::emit("{e:sandbox/%s}", S->getName().c_str());

        pair<string,int> loc = findFuncDeclaration(M, F);
        XO::Container location("location");
        XO::emit("{e:file/%s}{e:line/%d}",
                 loc.first.c_str(), loc.second);
        location.close();

        XO::emit("\n");
        map<Function*,StringSet>::iterator it = funcToCVEs.find(F);
        if (it == funcToCVEs.end()) {
          // vulnerable vendor func/library
          XO::emit("{e:type/%s}", "vulnerable_vendor");
          XO::emit(" *** Sandboxed function \"{d:function/%s}\" is from "
                   "a vulnerable vendor or library.\n",
                   F->getName().str().c_str());
          if (sandboxPlatform->doesProvideProtection()) {
            XO::emit("{e:restricted_rights/true}");
            XO::emit(" *** A vulnerability here would not grant ambient "
                     "authority to the attacker but would leak the "
                     "following restricted rights:\n");
          }
          else {
            XO::emit("{e:restricted_rights/false}");
            XO::emit(" *** A vulnerability here would leak ambient "
                     "authority to the attacker including full\n"
                     " *** network and file system access.\n"); 
            continue;
          }
        }
        else {
          // func with past vulnerabilities
          XO::emit("{e:type/%s}", "cve");
          StringSet CVEs = it->second;
          XO::emit(" *** Sandboxed function \"{d:function/%s}\" has "
                   "past-vulnerability annotations for \"{d:cves/%s}\".\n",
                   F->getName().str().c_str(),
                   stringifyStringSet(CVEs).c_str());
          XO::List cveList("cve");
          for (string cve : CVEs) {
            XO::Instance cveInstance(cveList);
            XO::emit("{e:id/%s}", cve.c_str());
          }
          cveList.close();
          if (sandboxPlatform->doesProvideProtection()) {
            XO::emit("{e:restricted_rights/%s}", "true");
            XO::emit(" *** Another vulnerability here would not grant ambient "
                     "authority to the attacker but would leak the "
                     "following restricted rights:\n");
          }
          else {
            XO::emit("{e:restricted_rights/%s}", "false");
            XO::emit(" *** Another vulnerability here would leak ambient "
                     "authority to the attacker including full\n"
                     " *** network and file system access.\n"); 
            continue;
          }
        }

        if (CmdLineOpts::EmitLeakedRights) {
          XO::Container rightsLeakedContainer("rights_leaked");

          // F may run in a sandbox
          // find out what was passed into the sandbox (shared global variables, file descriptors)
          SDEBUG("soaap.analysis.vulnerability", 3, dbgs() << "Checking leaking of global variables\n");
          GlobalVariableIntMap varToPerms = S->getGlobalVarPerms();
          if (!varToPerms.empty()) {
            XO::List globalList("global");
            XO::emit(" Global variables:\n");
            for (pair<GlobalVariable*,int> varPermPair : varToPerms) {
              XO::Instance globalInstance(globalList);
              GlobalVariable* G = varPermPair.first;
              int varPerms = varPermPair.second;
              StringRef varPermsStr = "";
              if (varPerms == (VAR_READ_MASK | VAR_WRITE_MASK)) {
                varPermsStr = "Read and write";
              }
              else if (varPerms & VAR_READ_MASK) {
                varPermsStr = "Read";
              }
              else if (varPerms) {
                varPermsStr = "Write";
              }
              if (varPermsStr != "") {
                XO::emit(" +++ {d:perms/%s} access to \"{:global_var/%s}\"\n",
                         varPermsStr.str().c_str(),
                         G->getName().str().c_str());
                XO::List permList("perm");
                if (varPerms & VAR_READ_MASK) {
                  XO::Instance permInstance(permList);
                  XO::emit("{e:type/%s}", "read");
                }
                if (varPerms & VAR_WRITE_MASK) {
                  XO::Instance permInstance(permList);
                  XO::emit("{e:type/%s}", "write");
                }
              }
            }
          }
          
          SDEBUG("soaap.analysis.vulnerability", 3, dbgs() << "Checking leaking of capabilities\n");
          ValueFunctionSetMap caps = S->getCapabilities();
          if (!caps.empty()) {
            XO::List capRightList("cap_right");
            XO::emit(" File descriptors:\n");
            for (pair<const Value*,FunctionSet> cap : caps) {
              const Argument* capArg = dyn_cast<const Argument>(cap.first);
              FunctionSet capPerms = cap.second;
              if (!capPerms.empty()) {
                XO::Instance capRightInstance(capRightList);
                XO::emit(" +++ Call {d:syscalls/%s} on file descriptor "
                         "\"{:fd/%s}\" passed into sandbox entrypoint "
                         "\"{:entry_point/%s}\"\n",
                         CallGraphUtils::stringifyFunctionSet(capPerms).c_str(),
                         capArg->getName().str().c_str(),
                         capArg->getParent()->getName().str().c_str());
                XO::List syscallList("syscall");
                for(Function* capPerm : capPerms) {
                  XO::Instance syscallInstance(syscallList);
                  XO::emit("{e:name/%s}", capPerm->getName().str().c_str());
                }
              }
            }
          }

          SDEBUG("soaap.analysis.vulnerability", 3, dbgs() << "Checking callgates\n");
          FunctionVector callgates = S->getCallgates();
          if (!callgates.empty()) {
            XO::List callgateList("callgate");
            XO::emit(" Call gates:\n");
            for (Function* F : callgates) {
              XO::Instance callgateInstance(callgateList);
              XO::emit(" +++ {:name/%s}\n",
                       F->getName().str().c_str());
            }
          }

          SDEBUG("soaap.analysis.vulnerability", 3, outs() << "Checking sandbox-private data\n");
          ValueSet privateData = S->getPrivateData();
          if (!privateData.empty()) {
            XO::List privateList("private");
            XO::emit(" Private data:\n");
            for (Value* V : privateData) {
              XO::Instance privateInstance(privateList);
              if (IntrinsicInst* annotateCall = dyn_cast<IntrinsicInst>(V)) {
                if (annotateCall->getIntrinsicID() == Intrinsic::var_annotation) {
                  // llvm.var.annotation
                  Value* annotatedVar = dyn_cast<Value>(annotateCall->getOperand(0)->stripPointerCasts());
                  XO::emit("{e:type/%s}", "local_var");
                  XO::emit(" +++ Local variable \"{:name/%s}\"\n",
                           annotatedVar->getName().str().c_str());
                }
                else if (annotateCall->getIntrinsicID() == Intrinsic::ptr_annotation) {
                  XO::emit("{e:type/%s}", "struct_member");
                  Value* annotatedVar = dyn_cast<Value>(annotateCall->getOperand(0)->stripPointerCasts());
                  XO::emit(" +++ Struct member \"{:name/%s}\"\n",
                           annotatedVar->getName().str().c_str());
                }
              }
              else if (GlobalVariable* G = dyn_cast<GlobalVariable>(V)) {
                XO::emit("{e:type/%s}", "global_var");
                XO::emit(" +++ Global variable \"{:name/%s}\"\n",
                         G->getName().str().c_str());
              }
            }
          }
          rightsLeakedContainer.close();
        }

        if (CmdLineOpts::isSelected(SoaapAnalysis::Vuln, CmdLineOpts::OutputTraces)) {
          CallGraphUtils::emitCallTrace(F, S, M);
        }

        SDEBUG("soaap.analysis.vulnerability", 3, outs() << "TODO: Check classified data\n");
      }
    }
    if (find(privilegedFuncs.begin(), privilegedFuncs.end(), F) != privilegedFuncs.end()) {
      // F may run with ambient authority
      XO::Instance vulnerabilityWarningInstance(vulnerabilityWarningList);
      XO::emit("{e:function/%s}", F->getName().str().c_str());
      XO::emit("{en:sandbox/null}");
      
      pair<string,int> loc = findFuncDeclaration(M, F);
      XO::Container locationContainer("location");
      XO::emit("{e:file/%s}{e:line/%d}",
               loc.first.c_str(), loc.second);
      locationContainer.close();
      XO::emit("{e:restricted_rights/false}");
      
      XO::emit("\n");
      map<Function*,StringSet>::iterator it = funcToCVEs.find(F);
      if (it == funcToCVEs.end()) {
        XO::emit("{e:type/%s}", "vulnerable_vendor");
        XO::emit(" *** Function \"{d:function/%s}\" is from a vulnerable "
                 "vendor.\n"
                 " *** A vulnerability here would leak ambient authority "
                 "to the attacker including full\n"
                 " *** network and file system access.\n",
                 F->getName().str().c_str()); 
      }
      else {
        XO::emit("{e:type/%s}", "cve");
        StringSet CVEs = it->second;
        XO::emit(" *** Function \"{d:function/%s}\" has "
                 "past-vulnerability annotations for \"{d:cves/%s}\".\n"
                 " *** Another vulnerability here would leak ambient "
                 "authority to the attacker including full\n"
                 " *** network and file system access.\n",
                 F->getName().str().c_str(),
                 stringifyStringSet(CVEs).c_str());
        XO::List cveList("cve");
        for (string cve : CVEs) {
          XO::Instance cveInstance(cveList);
          XO::emit("{e:id/%s}", cve.c_str());
        }
      }
      if (CmdLineOpts::isSelected(SoaapAnalysis::Vuln, CmdLineOpts::OutputTraces)) {
        CallGraphUtils::emitCallTrace(F, nullptr, M);
      }
    }
  }
}

string VulnerabilityAnalysis::stringifyStringSet(StringSet& strings) {
  string str = "[";
  bool first = true;
  for (string s : strings) {
    if (!first) 
      str += ",";
    str += s;
    first = false;
  }
  str += "]";
  return str;
}
